# Kubernetes에 Backend(Node.js) 배포: Deployment + ClusterIP Service 구축

---

## 1) 사전 점검 (클러스터 연결/노드 상태)

### 클러스터 연결 확인

```bash
kubectl version
kubectl get nodes -o wide
```

- `kubectl version`: kubeconfig가 정상이고 API 서버에 연결되는지 확인한다.
- `kubectl get nodes -o wide`: 노드가 모두 `Ready`인지, IP/역할이 정상인지 확인한다.

---

## 2) 배포 리소스 선택: 왜 Deployment + ClusterIP 인가?

### Deployment / StatefulSet / DaemonSet / Job 간단 비교

- **Deployment**
  → Stateless(상태 없는) 애플리케이션을 다중 Pod로 운영하고, 롤링 업데이트/스케일링을 쉽게 하기 위해 사용한다.
- **StatefulSet**
  → Pod 이름/순서/스토리지가 고정되어야 하는 상태ful 워크로드(DB 등)에 사용한다.
- **DaemonSet**
  → 모든 노드에 1개씩 떠야 하는 에이전트(로그 수집, 모니터링 등)에 사용한다.
- **Job/CronJob**
  → 한 번 실행 후 종료되는 배치/주기 작업에 사용한다.

### Backend(Node.js)에서 Deployment가 적절한 이유

- 서버는 **상태가 없는(stateless)** API 서버이므로 Deployment로 운영한다.
- Pod 개수(`replicas`)를 늘려 **가용성/부하분산**을 확보할 수 있다.
- 이미지 태그 변경 시 **롤링 업데이트**로 무중단에 가깝게 교체할 수 있다.

### Service는 ClusterIP를 사용하는 이유

- Ingress가 외부 트래픽을 받아 **내부 Service로 라우팅**하므로, Service는 **ClusterIP**가 적절하다.
- 외부 노출은 Ingress에서 처리한다.

---

## 3) Deployment 생성 (Backend 컨테이너 실행)

### Deployment YAML 작성

```bash
vim modules/deployments/my-node-deploy.yaml
```

```yaml
# modules/deployments/my-node-deploy.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-node
spec:
  replicas: 2
  selector:
    matchLabels:
      app: my-node
  template:
    metadata:
      labels:
        app: my-node
    spec:
      containers:
        - name: my-node
          image: sej1991/my-node:latest
          ports:
            - containerPort: 3000
          envFrom:
            - secretRef:
                name: my-node-secrets
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "300m"
              memory: "256Mi"
          readinessProbe:
            httpGet:
              path: /api
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /api
              port: 3000
            initialDelaySeconds: 15
            periodSeconds: 20
```

- `replicas: 2`: Backend Pod를 2개로 유지해 가용성을 확보한다.
- `labels`/`selector`: Service가 Pod를 찾는 기준. 반드시 일치해야 한다.
- `image: sej1991/my-node:latest`: Docker Hub에서 이미지 pull.
- `envFrom.secretRef`: DB 접속 정보 등 **민감 정보**를 Secret에서 주입.
- `readinessProbe`/`livenessProbe`: `/api` 경로로 헬스 체크. 200 OK가 반환되어야 정상.

---

## 4) Secret 생성 (DB 연결 정보 주입)

```bash
vim modules/secrets/my-node-secrets.yaml
```

```yaml
# modules/secrets/my-node-secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-node-secrets
type: Opaque
stringData:
  PORT: "3000"
  POSTGRES_HOST: postgres
  POSTGRES_PORT: "5432"
  POSTGRES_USER: myuser
  POSTGRES_PASSWORD: qwer
  POSTGRES_NAME: mydb
```

- `POSTGRES_HOST`: DB Service 이름(`postgres`)로 설정한다.
- `stringData`: 사람이 읽기 쉬운 형태로 작성하면 Kubernetes가 자동으로 base64 인코딩한다.

---

## 5) Service 생성 (ClusterIP)

```bash
vim modules/services/my-node-serivce.yaml
```

```yaml
# modules/services/my-node-serivce.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-node-svc
spec:
  selector:
    app: my-node
  ports:
    - name: http
      port: 3000
      targetPort: 3000
  type: ClusterIP
```

- `ClusterIP`: 클러스터 내부 접근용. 외부 노출은 Ingress에서 처리한다.
- `selector.app`: `my-node` Pod로 트래픽 전달.

---

## 6) 적용 순서

```bash
kubectl apply -f modules/secrets/my-node-secrets.yaml
kubectl apply -f modules/deployments/my-node-deploy.yaml
kubectl apply -f modules/services/my-node-serivce.yaml
```

---

## 7) 상태 확인

```bash
kubectl get deploy my-node
kubectl get pods -l app=my-node -o wide
kubectl get svc my-node-svc -o wide
kubectl rollout status deploy/my-node
```

---

## 8) 트러블슈팅 빠른 체크

### Pod가 CrashLoopBackOff일 때

```bash
kubectl logs deploy/my-node --tail=200
kubectl describe pod -l app=my-node
```

- 프로브 경로(`/api`)가 실제로 200을 반환하는지 확인.
- 이미지가 최신인지 확인.

### DB 연결 실패

```bash
kubectl exec -it deploy/my-node -- sh -c 'nc -zv postgres 5432'
```

- `postgres:5432`가 열려 있어야 한다.
- Secret 값이 올바른지 확인한다.

---

# 빠른 요약

- Backend는 Stateless이므로 Deployment로 배포한다.
- Service는 ClusterIP로 구성하고, 외부 노출은 Ingress에 맡긴다.
- DB 연결 정보는 Secret으로 관리한다.
- `/api` 헬스 체크가 정상이어야 Ready 상태가 된다.

---
