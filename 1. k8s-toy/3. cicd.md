# GitHub Actions CI/CD 구성: Buildx로 Docker Hub Push + Kubernetes 롤링 업데이트

---

## 1) 목표(자동화 범위) 정의

- GitHub에 `push`가 발생하면 자동으로 아래를 수행한다.
  - Docker Buildx로 이미지 빌드
  - Docker Hub로 이미지 push
  - Kubernetes Deployment 이미지 교체(`kubectl set image`)
  - 롤링 업데이트 완료 확인(`kubectl rollout status`)

---

## 2) 트리거(on) 설정: 언제 실행되는가?

```yaml
on:
  push:
    branches:
      - main
    tags:
      - 'v*'
```

- `branches: [main]`
  → main 브랜치에 push되면 워크플로우가 실행된다.
- `tags: ['v*']`
  → `v1`, `v1.0.0` 같은 태그를 push하면 워크플로우가 실행된다.

---

## 3) Action Runner 선택: 왜 self-hosted 인가?

```yaml
runs-on: self-hosted
```

- **self-hosted runner**
  → Vagrant/사설망 Kubernetes 클러스터에 `kubectl`로 접근하기 위해 사용했다.
- GitHub-hosted runner는 기본적으로 외부망 환경이어서, 사설 IP 클러스터 접근이 어려울 수 있다.

---

## 4) Docker Hub Secrets 준비

### GitHub Secrets에 등록할 값

- `DOCKERHUB_USERNAME`
  → Docker Hub 계정 아이디
- `DOCKERHUB_TOKEN`
  → Docker Hub Access Token (비밀번호 대신 권장)

---

## 5) Kubernetes kubeconfig 준비 (runner가 kubectl 실행 가능해야 함)

> 너는 runner 머신(예: vagrant 사용자)의 kubeconfig를 직접 사용했다.

```bash
export KUBECONFIG=/home/vagrant/.kube/config
```

- `KUBECONFIG` 환경변수로 `kubectl`이 사용할 kubeconfig 파일 경로를 지정한다.
- `/home/vagrant/.kube/config`는 vagrant 계정이 읽을 수 있어야 한다(권한 중요).

---

## 6) Workflow 파일 작성

### Workflow 파일 생성

```bash
mkdir -p .github/workflows
vim .github/workflows/docker-image.yaml
```

- GitHub Actions는 `.github/workflows/*.yml` 파일을 감지해 워크플로우를 실행한다.

---

### Workflow 전체 예시

```yaml
name: Build, Push Docker Image & Deploy to Kubernetes

on:
  push:
    branches:
      - main
    tags:
      - 'v*'

jobs:
  build-push-deploy:
    runs-on: self-hosted

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and Push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            sej1991/my-react-vite:latest
            sej1991/my-react-vite:${{ github.ref_name }}

      - name: Deploy to Kubernetes
        run: |
          export KUBECONFIG=/home/vagrant/.kube/config
          kubectl set image deployment/my-react my-react=sej1991/my-react-vite:${{ github.ref_name }}
          kubectl rollout status deployment/my-react
          kubectl get pods -o wide
```

---

## 7) 핵심 동작 설명(스텝별)

### Checkout source

- 레포 소스코드를 runner 머신으로 가져온다(이후 Docker build에 사용).

### Set up Docker Buildx

- `docker buildx`(빌드킷 기반 확장 빌더)를 사용할 수 있게 준비한다.
- `docker/build-push-action@v5`는 Buildx가 필요하다.

### Login to Docker Hub

- Docker Hub에 인증해서 push가 가능하도록 한다.

### Build and Push Docker image

- `tags`에 2개를 동시에 push한다.
  - `sej1991/my-react-vite:latest`
    → 항상 최신으로 덮어쓰는 태그
  - `sej1991/my-react-vite:${{ github.ref_name }}`
    → 브랜치/태그 이름으로 태깅되는 “식별 가능한 태그” - main 브랜치 push면 `ref_name=main` → `:main` - 태그 push면 `ref_name=v1.0.0` → `:v1.0.0`

### Deploy to Kubernetes

- `kubectl set image`로 Deployment의 컨테이너 이미지를 `:${{ github.ref_name }}`로 교체한다.
- `kubectl rollout status`로 롤링 업데이트 완료까지 대기한다.
- 마지막에 `kubectl get pods -o wide`로 배포 결과를 확인한다.

---

## 8) 트러블슈팅

### (에러 1) Docker buildx is required

**에러 메시지**

```
Error: Docker buildx is required. See <https://github.com/docker/setup-buildx-action> to set up buildx.
```

**원인**

- self-hosted runner 머신에 `docker buildx`가 없거나,
- Docker/Buildx 플러그인 설치가 누락되었거나,
- runner 유저가 docker daemon에 접근하지 못해 buildx가 정상 초기화되지 않은 경우가 많다.

**해결(점검 순서)**

```bash
docker version
docker buildx version
docker info

# Ubuntu 계열에서 흔한 추가 조치(권한)
sudo usermod -aG docker vagrant
# 이후 runner/세션 재시작 필요
```

- `docker buildx version`이 실패하면 buildx 플러그인이 없는 상태일 가능성이 크다.
- runner 머신에 buildx 플러그인을 설치하거나, Docker를 최신 버전으로 설치한다.

---

### (에러 2) admin.conf permission denied

**에러 메시지**

```
error: error loading config file "/etc/kubernetes/admin.conf": open /etc/kubernetes/admin.conf: permission denied
```

**원인**

- `/etc/kubernetes/admin.conf`는 보통 root 권한 파일이라 일반 유저(runner)가 읽지 못한다.

**해결**

```bash
mkdir -p ~/.kube

# /etc/kubernetes/admin.conf
# → 클러스터 관리자(admin) 권한 kubeconfig
# 	•	Kubespray / kubeadm이 control plane에서 생성
#	  •	이 파일을 사용자 홈의 기본 위치로 복사
sudo cp /etc/kubernetes/admin.conf ~/.kube/config

# 복사된 ~/.kube/config 파일의 소유자를 vagrant로 변경
# 안 하면:
#	•	파일은 root 소유
#	•	vagrant가 읽지 못함
#	•	permission denied 에러 발생
sudo chown vagrant:vagrant ~/.kube/config
```

- 이후 workflow에서는 사용자 kubeconfig를 사용한다.

```bash
export KUBECONFIG=/home/vagrant/.kube/config
```

- `admin.conf`를 그대로 쓰기보다, CI/CD 전용 ServiceAccount + 최소 권한 kubeconfig를 만들어 사용하는 것이 더 안전하다. → 공부 필요

---

# 빠른 요약

- GitHub Actions에서 Docker Buildx로 이미지를 빌드하고 Docker Hub에 `latest`와 `${{ github.ref_name }}` 태그로 push했다.
- self-hosted runner를 사용해 사설망 Kubernetes 클러스터에 `kubectl`로 접근했다.
- `kubectl set image`로 Deployment 이미지를 교체해 롤링 업데이트 배포를 자동화했다.

---
